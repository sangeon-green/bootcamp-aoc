(ns aoc2020-8
  (:require [clojure.core]
            [clojure.java.io :as io]
            [clojure.string :as str]))


(defn 명령-수치-키값-생성 [입력값]
  "입력된 문자열을 분리하여 {:명령 :수치} 형태로 만들어 줌"
  (->> 입력값
   (map #(str/split % #" "))
   (mapv (fn [[명령 수치]] {:명령 명령 :수치 수치}))))


(def 전체명령어
  "명령어가 있는 파일을 읽어와서 {:명령 :수치} 가지는 vector로 만들어 줌"
  (->> (io/resource "2020_day8.sample-light.txt")
       slurp
       str/split-lines
       명령-수치-키값-생성))

;; 변경되는 상태 값을을 저장하기 위해 선언
(def 전역-상태 {:계산된값 0 :실행된행 #{} :현재행 0 })

(defn 명령어실행 [전역상태]
  "입력된 명령어가 두번 실행되는 경우를 찾는 함수"
  (let [현재진행행 (:현재행 전역상태)
        선택된행 (nth 전체명령어 (:현재행 전역상태))]
    (if ((:실행된행 전역상태) 현재진행행)
      {:두번째실행 true :계산된값 (:계산된값 전역상태)}
      (cond
        (= (:명령 선택된행) "nop")
        (merge 전역상태
               {:현재행 (inc 현재진행행)
                :실행된행 (conj (:실행된행 전역상태) 현재진행행)})
        (= (:명령 선택된행) "acc")
        (merge 전역상태
               {:계산된값 (+ (:계산된값 전역상태) (Integer/parseInt (:수치 선택된행)))
                :현재행 (inc 현재진행행)
                :실행된행 (conj (:실행된행 전역상태) 현재진행행)})
        (= (:명령 선택된행) "jmp")
        (merge 전역상태
               {:현재행 (+ 현재진행행 (Integer/parseInt (:수치 선택된행)))
                :실행된행 (conj (:실행된행 전역상태) 현재진행행)})))))

;; ## 파트 1
;; 일련의 지시가 입력으로 주어진다.
;; - **acc**는 전역 변수를 증가/감소 시키는 역할을 한다. acc +7은 accumulator를 7 증가 시킨다. accumulator는 0에서 시작한다.
;; - **jmp**는 현재 위치에 기반하여 새로운 지시로 넘어간다. jmp +1은 바로 다음의 지시로 넘어가는 것이고, jmp +2는 바로 다음의 지시는 건너뛰고 그 다음의 지시를 실행하는 것이다.
;; - **nop** 는 아무것도 하지 않는다.
;;   아래는 예시이다.
;; ```
;; nop +0
;; acc +1
;; jmp +4
;; acc +3
;; jmp -3
;; acc -99
;; acc +1
;; jmp -4
;; acc +6
;; ```
;; 위의 예시는 아래의 순서로 실행된다.
;; ```
;; nop +0  | 1
;; acc +1  | 2, 8(!)
;; jmp +4  | 3
;; acc +3  | 6
;; jmp -3  | 7
;; acc -99 |
;; acc +1  | 4
;; jmp -4  | 5
;; acc +6  |
;; ```
;; 이 지시들은 무한히 반복된다.

;; 한 지시가 정확히 **두번 실행되는 시점 바로 전**의 acc의 값을 반환하라.
;; 위의 예시에선 acc +1이 8번째 틱에서 정확히 두번 실행되고, 이 때의 acc의 값은 5이다.

; Part 1
(defn 두번실행되는명령어찾기 [전역상태]
  "입력된 명령어가 두번 실행되는 경우를 찾기 위해 두번 반복이 될때까지 loop를 돌려서 명령어를 실행함"
  (loop [index 0]
    (if (true? (:두번째실행 (nth (iterate 명령어실행 전역상태) index)))
      (nth (iterate 명령어실행 전역상태) index)
      (recur (inc index)))))

(->> (두번실행되는명령어찾기 전역-상태)
     :계산된값)

;; ## 파트 2
;; 주어진 지시들 중, 정확히 하나의 지시가 잘못된 것을 알게 되었다.
;; 정확히 하나의 jmp가 nop가 되어야하거나, nop가 jmp가 되면 프로그램은 **종료**된다.

;; ```
;; nop +0  | 1
;; acc +1  | 2
;; jmp +4  | 3
;; acc +3  |
;; jmp -3  |
;; acc -99 |
;; acc +1  | 4
;; nop -4  | 5 ;; 여기!
;; acc +6  | 6
;; ```

;; 위의 예시에서, "여기!" 라고 표기된 곳이 jmp에서 nop로 바뀌면, 지시는 무한히 반복하지 않고 마지막에 6을 반환하며 종료된다.
;; 프로그램이 종료되는 시점의 accumulator의 값을 반환하여라.


(def 모든-jmp-인덱스-가져오기
  (->> (map-indexed (fn [index 값] (if (= (:명령 값) "jmp") index)) 전체명령어)
       (partial filter #(not= nil %))))

(def 모든-jmp를-nop으로-순차적으로-변경
  (->> (모든-jmp-인덱스-가져오기)
       (map (fn [index] (assoc-in 전체명령어 [index :명령] "nop")))))

;;jmp가 nop변한 값을 돌면서 마지막에 온 것을 증명하는 방법